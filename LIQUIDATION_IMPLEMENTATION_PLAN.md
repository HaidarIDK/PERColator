# Liquidation System Implementation Plan

## Overview
Full implementation of the liquidation testing specification covering:
- Router liquidation logic with health monitoring
- Off-chain Keeper service with priority queue
- TOCTOU protection and oracle alignment
- Comprehensive testing framework (65+ tests)

## Phase 1: Core Router Infrastructure (Week 1)

### 1.1 State Extensions
**Files to modify:**
- `programs/router/src/state/registry.rs` - Add liquidation parameters
- `programs/router/src/state/portfolio.rs` - Add health tracking

**New fields for SlabRegistry:**
```rust
pub imr: u64,               // Initial margin ratio (basis points)
pub mmr: u64,               // Maintenance margin ratio (basis points)
pub liq_band_bps: u64,      // Liquidation price band (basis points)
pub preliq_buffer: i128,    // Pre-liquidation buffer
pub preliq_band_bps: u64,   // Pre-liquidation tighter band
pub router_cap_per_slab: u64, // Maximum size per slab
pub min_equity_to_quote: i128, // Minimum equity to provide quotes
```

**New fields for Portfolio:**
```rust
pub health: i128,           // equity - MM
pub last_liquidation_ts: u64, // For rate limiting
pub cooldown_seconds: u64,   // Deleveraging cooldown
```

### 1.2 Liquidation Instruction
**New file:** `programs/router/src/instructions/liquidate_user.rs`

**Signature:**
```rust
pub fn process_liquidate_user(
    portfolio: &mut Portfolio,
    registry: &SlabRegistry,
    vault: &mut Vault,
    router_authority: &AccountInfo,
    oracle_accounts: &[AccountInfo],
    slab_accounts: &[AccountInfo],
    receipt_accounts: &[AccountInfo],
    is_preliq: bool,  // Pre-liquidation vs hard liquidation
) -> Result<(), PercolatorError>
```

**Logic:**
1. Calculate health = equity - MM
2. Check trigger: `health < 0` (hard) or `0 <= health < preliq_buffer` (pre-liq)
3. Read oracle prices for all instruments
4. Call reduce-only planner
5. Execute via internal call to execute_cross_slab logic
6. Update portfolio health
7. Emit LiquidationStart/Fill/End events

### 1.3 Reduce-Only Planner
**New file:** `programs/router/src/liquidation/planner.rs`

**Functions:**
```rust
pub struct LiquidationPlan {
    pub splits: Vec<SlabSplit>,
    pub expected_reduction: i64,
    pub band_px_low: i64,
    pub band_px_high: i64,
}

pub fn plan_reduce_only(
    portfolio: &Portfolio,
    registry: &SlabRegistry,
    oracle_prices: &[(u16, i64)],  // (instrument_idx, price)
    slab_marks: &[(Pubkey, i64)],   // (slab_id, mark_price)
    is_preliq: bool,
) -> Result<LiquidationPlan, PercolatorError>
```

**Algorithm:**
1. For each exposure in portfolio:
   - If qty > 0 (long), plan sell
   - If qty < 0 (short), plan buy
2. Oracle alignment: exclude slabs where |mark - oracle| > epsilon
3. Apply banding: limit_px within [oracle * (1 - band), oracle * (1 + band)]
4. Apply per-slab caps: clamp each split to router_cap_per_slab
5. Return aggregated plan with expected reduction

### 1.4 Oracle Alignment Gate
**New file:** `programs/router/src/liquidation/oracle.rs`

**Functions:**
```rust
pub const ORACLE_TOLERANCE_BPS: u64 = 50; // 0.5%

pub fn validate_oracle_alignment(
    slab_mark: i64,
    oracle_price: i64,
) -> bool {
    let diff = (slab_mark - oracle_price).abs();
    let threshold = (oracle_price * ORACLE_TOLERANCE_BPS as i64) / 10_000;
    diff <= threshold
}

pub fn filter_aligned_slabs(
    slabs: &[SlabInfo],
    oracles: &[(u16, i64)],
) -> Vec<SlabInfo>
```

## Phase 2: TOCTOU Protection (Week 1)

### 2.1 Slab Seqno Validation
**File to modify:** `programs/slab/src/instructions/commit_fill.rs`

**Add at entry:**
```rust
pub fn process_commit_fill(
    slab: &mut SlabState,
    receipt_account: &AccountInfo,
    router_signer: &Pubkey,
    expected_seqno: u32,  // NEW: Router passes expected seqno
    side: Side,
    qty: i64,
    limit_px: i64,
) -> Result<(), PercolatorError> {
    // TOCTOU Check
    if slab.header.seqno != expected_seqno {
        msg!("Error: Seqno mismatch - book changed since read");
        return Err(PercolatorError::SeqnoMismatch);
    }

    // ... rest of existing logic
}
```

### 2.2 Router CPI Update
**File to modify:** `programs/router/src/instructions/execute_cross_slab.rs`

**Before CPI, read seqno from each slab and pass it in instruction data.**

## Phase 3: Off-chain Keeper Service (Week 2)

### 3.1 Keeper Service Structure
**New directory:** `keeper/`

**Files:**
```
keeper/
├── Cargo.toml
├── src/
│   ├── main.rs           # Main event loop
│   ├── priority_queue.rs # Min-heap by health
│   ├── health.rs         # Health calculation
│   ├── oracle.rs         # Oracle price fetching
│   ├── tx_builder.rs     # Build liquidation txs
│   └── config.rs         # Configuration
```

### 3.2 Priority Queue
**File:** `keeper/src/priority_queue.rs`

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;

#[derive(Clone)]
pub struct UserHealth {
    pub user: Pubkey,
    pub portfolio: Pubkey,
    pub health: i128,
    pub equity: i128,
    pub mm: u128,
    pub last_update: u64,
}

impl Ord for UserHealth {
    fn cmp(&self, other: &Self) -> Ordering {
        // Min-heap: lowest health first
        other.health.cmp(&self.health)
    }
}

pub struct HealthQueue {
    heap: BinaryHeap<UserHealth>,
    map: HashMap<Pubkey, UserHealth>,
}

impl HealthQueue {
    pub fn push(&mut self, user_health: UserHealth);
    pub fn pop(&mut self) -> Option<UserHealth>;
    pub fn update(&mut self, user: &Pubkey, new_health: UserHealth);
    pub fn peek(&self) -> Option<&UserHealth>;
}
```

### 3.3 Event Subscription
**File:** `keeper/src/main.rs`

```rust
#[tokio::main]
async fn main() -> Result<()> {
    let config = Config::load()?;
    let client = RpcClient::new(config.rpc_url);
    let mut queue = HealthQueue::new();

    // Subscribe to Router program logs
    let (mut stream, _unsub) = client
        .logs_subscribe(
            RpcTransactionLogsFilter::Mentions(vec![config.router_program.to_string()]),
            RpcTransactionLogsConfig { commitment: Some(CommitmentConfig::confirmed()) },
        )
        .await?;

    // Main event loop
    loop {
        tokio::select! {
            // Process new events
            Some(log) = stream.next() => {
                process_log(&mut queue, log).await?;
            }

            // Check for liquidations every 1s
            _ = tokio::time::sleep(Duration::from_secs(1)) => {
                process_liquidations(&mut queue, &client, &config).await?;
            }
        }
    }
}
```

### 3.4 Health Calculation
**File:** `keeper/src/health.rs`

```rust
pub fn calculate_health(
    portfolio: &Portfolio,
    oracle_prices: &HashMap<u16, i64>,
) -> i128 {
    let equity = calculate_equity(portfolio, oracle_prices);
    let mm = calculate_mm(portfolio, oracle_prices);
    equity - mm as i128
}

pub fn calculate_equity(
    portfolio: &Portfolio,
    oracle_prices: &HashMap<u16, i64>,
) -> i128 {
    let mut equity = portfolio.equity;

    for i in 0..portfolio.exposure_count as usize {
        let (slab_idx, instrument_idx, qty) = portfolio.exposures[i];
        let price = oracle_prices.get(&instrument_idx).unwrap_or(&0);
        let pnl = qty as i128 * *price as i128 / 1_000_000;
        equity += pnl;
    }

    equity
}
```

## Phase 4: Pre-liquidation Deleveraging (Week 2)

### 4.1 Add Deleveraging Trigger
**File to modify:** `programs/router/src/instructions/liquidate_user.rs`

```rust
pub enum LiquidationMode {
    PreLiquidation,  // MM < equity < MM + buffer
    HardLiquidation, // equity < MM
}

pub fn determine_mode(health: i128, buffer: i128) -> Option<LiquidationMode> {
    if health < 0 {
        Some(LiquidationMode::HardLiquidation)
    } else if health > 0 && health < buffer {
        Some(LiquidationMode::PreLiquidation)
    } else {
        None
    }
}
```

### 4.2 Rate Limiting
**File to modify:** `programs/router/src/state/portfolio.rs`

```rust
impl Portfolio {
    pub fn check_cooldown(&self, current_ts: u64) -> bool {
        current_ts - self.last_liquidation_ts >= self.cooldown_seconds
    }

    pub fn update_liquidation_ts(&mut self, ts: u64) {
        self.last_liquidation_ts = ts;
    }
}
```

## Phase 5: Testing Infrastructure (Week 3-4)

### 5.1 Router Unit Tests
**New file:** `programs/router/src/liquidation/tests.rs`

Tests R-U1 through R-U6:
- Health computation
- Liquidation trigger
- Reduce-only planner
- Banding
- Oracle alignment gate
- Per-slab caps

### 5.2 Slab Unit Tests
**File to modify:** `programs/slab/src/instructions/commit_fill_test.rs`

Tests S-U1 through S-U5:
- QuoteCache coherence
- commit_fill price/time + limit
- TOCTOU rejection
- Receipt single-write
- Write scope

### 5.3 Keeper Unit Tests
**New file:** `keeper/src/priority_queue_test.rs`

Tests K-U1 through K-U3:
- Priority queue correctness
- Event integration
- Staleness handling

### 5.4 Integration Tests
**New file:** `tests/liquidation/mod.rs`

Tests I-L1 through I-L7, I-D1 through I-D2:
- Hard liquidation happy path
- Multi-slab liquidation split
- Partial depth, iterative liquidation
- TOCTOU during liquidation
- Misaligned slab exclusion
- Keeper-driven liquidation loop
- Reduce-only guard
- Pre-liq buffer trigger
- Rate limiting

### 5.5 Failure Injection Tests
**New file:** `tests/liquidation/failure_tests.rs`

Tests F-B1 through F-B6:
- Slab deny service
- Receipt reuse
- Bad account ordering
- CU pressure
- Oracle gap
- Per-slab cap breach

### 5.6 Accounting Tests
**New file:** `tests/liquidation/accounting_tests.rs`

Tests A-E1 through A-E4:
- Conservation
- Fees
- Net IM
- Health monotonicity

### 5.7 Determinism Tests
**New file:** `tests/liquidation/determinism_tests.rs`

Tests D-R1 through D-R2:
- Replay stability
- Idempotence of failure

## Implementation Order

1. **Day 1-2**: State extensions (1.1)
2. **Day 3-4**: Liquidation instruction skeleton (1.2)
3. **Day 5-6**: Reduce-only planner (1.3) + Oracle alignment (1.4)
4. **Day 7**: TOCTOU protection (2.1, 2.2)
5. **Day 8-10**: Keeper service (3.1-3.4)
6. **Day 11-12**: Pre-liquidation deleveraging (4.1-4.2)
7. **Day 13-15**: Router unit tests (5.1)
8. **Day 16-17**: Slab unit tests (5.2)
9. **Day 18-19**: Keeper unit tests (5.3)
10. **Day 20-22**: Integration tests (5.4)
11. **Day 23-24**: Failure injection tests (5.5)
12. **Day 25-26**: Accounting tests (5.6)
13. **Day 27-28**: Determinism tests (5.7)

## Success Criteria

All 65+ tests pass with:
- Zero stack overflow warnings
- CU budget < 200k for worst-case liquidation
- Deterministic replay across 20 runs
- All invariants enforced
- Atomic rollback on all failures

## Current Status: NOT STARTED

Next step: Begin Phase 1.1 - State Extensions
